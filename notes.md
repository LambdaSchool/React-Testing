# Day 3

## Today

- snapshot testing
- component testing
- fakes, stubs, and mock functions a.k.a. spies

### Snapshot Testing

- sub-type of component testing
- very useful for spot regressions
- `automatically created by Jest`
- a snapshot is a JSON based record of a component's output
- snapshots are saved to `__snapshots__` folder as a sibling of the tested component
- during testing, the components are automatically compared to the last recorded snapshot
- fails with any change to the component
- the snapshots are commited to source control (`git`)

**Snapshot Workflow**

- first, install `react-test-renderer` if you haven't
- second `import renderer from 'react-test-renderer`;
- then `import { TheComponent } from './TheComponent`;
- create a tree (think tree of nodes)
- run the assertion to match snapshot

```type:Javascript:
import renderer from 'react-test-renderer';
import { TheComponent } from './TheComponent';
const tree = renderer.create(<TheComponent />);

expect(tree.toJSON()).toMatchSnapshot();
```

- the fist time this is done, the snapshot is created
- when the snapshot fails, the developer can decide to update the snapshot if the change was intended
- to update the snapshot, `jest TheComponent -u` or `jest TheComponent --update`
    - if you used `create-react-app` the command is `yarn test -u`

**Snapshot Pros and Cons**

- fast and semi-automatic
- catches regressions that could be missed by humans
- works with any library that generates HTML components (Angular, Vue, React)
- better than no tests at all to protect applications from regressions
- easy to override, save new snapshot
- protects only against regression
- easy to break, smallest change will fail test suite
- adds more files to the repository
- waste of time to have them while actively making changes to components

### Component Testing

- appearance and functionality
- highly sensitive to small changes
- great against regression
- verifies changes to component output resulting from changes to state
- does **NOT** verify interaction between components

**What do we test?**
- does it render?
- does it render correctly?
- are sub-components rendered, and how many of them
- are props handled correctly
- is state handled correctly
- does it handle events correctly
**we are not testing CSS**

**What makes a good test?**
- should be independent
- tests only what you need
- one test per behavior/functionality (multiple assertions are ok)
- one code unit at a time

**Workflow**

- render component in isolation without any sub components. This is called `shallow rendering`.
- we'll use a library called `enzyme` for `shallow rendering`
- inside the README.md file generated by `create-react-app` there are instructions on how to add `enzyme` to the project.

**Install Enzyme**

- type: `yarn add enzyme enzyme-adapter-react-16 react-test-renderer`
- add a global setup file: `src/setupTests.js`

```type:Javascript

import { configure } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';

configure({ adapter: new Adapter() });

```

**Using enzyme**
- add library
- add this code to App.test.js

```type:js

import { shallow } from 'enzyme';
describe("App Component", () => {
    it("renders without crashing"), () => {
        shallow( <App />); 
        //notice this only renders App and will 
        //not render any child components
    });
});

```

### Mocks

- duplicate of a unit of code that has no implementation
- has the same API (method names, return value type, and shape must be returned) of the original unit, but has no side effects.
- prevent side effects
- reduce dependencies
- isolate tests to simplify testing
- add mocks to a `__mocks__` folder next to the mocked module.
- to mock npm modules, just name your mock the same as the module and it will be loaded automatically
    - folder must be at the root of the application, next to the `node_modules` folder.
    - add a file inside the folder with the name of the module you want to mock.

- to mock local files
    - add the `__mocks__` folder at the same level of the file to mock.
    - where the mock is needed call `jest.mock('insert pathname of file to be mocked')`

### Spies

Spies are functions that provide information about how they are used

- counts function calls
- records arguments passed to it when it is called
- we can return fake values in order to test specific scenarios
- to create `spies`:

```
const jamesBond = jest.fn();
```

- passing a function as the first argument, wraps that function into a spy that then keeps track of useful information. 